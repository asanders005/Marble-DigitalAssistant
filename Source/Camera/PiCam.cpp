#include "PiCam.h"

#include <core/buffer_sync.hpp>
#include <core/completed_request.hpp>
#include <core/frame_info.hpp>
#include <core/still_options.hpp>
#include <image/image.hpp>

#include <atomic>
#include <fstream>
#include <iostream>
#include <memory>

// Code generated by GitHub Copilot, edited by Aiden Sanders

void PiCam::ConfigureStill(unsigned int width, unsigned int height, int quality)
{
    // set values into the camera's options (OptsInternal) via Options::Set()
    camera.GetOptions()->Set().width   = width;
    camera.GetOptions()->Set().height  = height;
    camera.GetOptions()->Set().encoding = "jpg";
    camera.GetOptions()->Set().quality = quality;
    // When you call camera.ConfigureStill(), pass any flags you need, e.g.:
    // camera.ConfigureStill(RPiCamApp::FLAG_STILL_NONE);
    
    stillConfigured = true;
}

void PiCam::ConfigureVideo(unsigned int width, unsigned int height, float framerate, int bitrate)
{
    // Use Set() to change the underlying OptsInternal members.
    encoder.GetOptions()->Set().width = width;
    encoder.GetOptions()->Set().height = height;
    encoder.GetOptions()->Set().framerate = static_cast<float>(framerate);
    encoder.GetOptions()->Set().bitrate.set(std::to_string(bitrate) + "bps");
    encoder.GetOptions()->Set().codec = "h264";

    videoConfigured = true;
}

void PiCam::CaptureStill(const std::string &outFile)
{
    if (!stillConfigured)
    {
        ConfigureStill(1920, 1080);
    }
    
    camera.OpenCamera();
    camera.ConfigureStill();
    camera.StartCamera();
    
    auto msg = camera.Wait();
    if (msg.type != RPiCamApp::MsgType::RequestComplete)
    {
        camera.StopCamera();
        camera.CloseCamera();
        throw std::runtime_error("Failed to capture still image.");
    }

    auto complete = std::get<CompletedRequestPtr>(msg.payload);

    RPiCamApp::Stream* imgStream = camera.StillStream(nullptr);
    if (!imgStream)
    {
        camera.StopCamera();
        camera.CloseCamera();
        throw std::runtime_error("Failed to get image stream.");
    }

    auto info = camera.GetStreamInfo(imgStream);

    BufferReadSync reader(&camera, complete->buffers[imgStream]);
    const auto& mem = reader.Get();

    std::string outPath = "build/Assets/Images/" + outFile;
    jpeg_save(mem, info, complete->metadata, outPath, camera.CameraModel(),
               static_cast<StillOptions const*>(camera.GetOptions()));

    camera.StopCamera();
    camera.CloseCamera();
}

void PiCam::CaptureVideo(const std::string &outFile, int durationSeconds)
{
    if (!videoConfigured)
    {
        ConfigureVideo(1920, 1080);
    }
    
    // Open/Configure/Start
    encoder.OpenCamera();
    encoder.ConfigureVideo();
    encoder.StartCamera();

    // Hook to receive encoded output. encode callback receives (void* mem, size_t size, int64_ts, bool eos)
    std::ofstream ofs("build/Assets/Videos/" + outFile, std::ios::binary);
    encoder.SetEncodeOutputReadyCallback([&ofs](void *mem, size_t size, int64_t /*ts*/, bool /*eos*/) {
        if (mem && size) ofs.write(reinterpret_cast<char*>(mem), size);
    });
    
    // Create encoder internals and start encoding
    encoder.StartEncoder();

    // Run for durationSeconds, processing request-complete messages and asking the encoder
    auto start = std::chrono::steady_clock::now();
    while (std::chrono::duration_cast<std::chrono::seconds>(std::chrono::steady_clock::now() - start).count() < durationSeconds) {
        auto msg = encoder.Wait();
        if (msg.type == RPiCamApp::MsgType::RequestComplete) {
            auto completed = std::get<CompletedRequestPtr>(msg.payload);
            // Get the video stream (RPiCamEncoder::VideoStream())
            RPiCamApp::Stream *video_stream = encoder.VideoStream(nullptr);
            if (video_stream) {
                // Ask encoder to encode this completed request (it will call your callback with encoded bytes)
                bool started = encoder.EncodeBuffer(completed, video_stream);
                (void)started; // if false, the frame was skipped (e.g. sync not ready)
            }
        } else if (msg.type == RPiCamApp::MsgType::Quit) {
            break;
        }
    }

    // Stop encoder and camera
    encoder.StopEncoder();
    encoder.StopCamera();
    encoder.CloseCamera();
    ofs.close();
}